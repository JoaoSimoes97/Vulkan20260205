# Multi-Tier Instance Rendering System

> A GPU-optimized instancing architecture designed for scalability, shadows, and ray tracing.

---

## Current Implementation Status (2026-02-25)

**UPDATE (2026-02-25):** GPU culling compute shader has been implemented and is running
alongside CPU culling for verification. The GPU culler is controlled via config option
`enable_gpu_culling` in `config.json`.

### What's Currently Working

| Component | Status | Notes |
|-----------|--------|-------|
| InstanceTier enum | ✅ Working | In `src/scene/object.h` |
| TieredInstanceManager | ✅ Working | `src/render/tiered_instance_manager.h/cpp` |
| BatchedDrawList | ✅ Working | Per-tier batching via `BatchKey.tier` |
| Per-object dirty flags | ✅ Working | `mutable bDirty` in Object |
| Triple-buffer SSBO | ✅ Working | Ring buffer with frames-in-flight tracking |
| CPU Frustum Culling | ✅ Working | `src/render/render_list_builder.cpp` |
| GPU Frustum Culling | ✅ Working | `src/render/gpu_culler.h/cpp`, `gpu_cull.comp` |
| VulkanComputePipeline | ✅ Working | `src/vulkan/vulkan_compute_pipeline.h/cpp` |
| Culling Stats Readback | ✅ Working | GPU/CPU visible count comparison in ImGui |

### Current Architecture (Hybrid CPU+GPU)

```
CPU: Build batches → Write ALL to SSBO → GPU: Compute cull (parallel) → Readback stats
                  ↓                                                          ↓
         CPU frustum cull → Batched draw (drives rendering)   GPU stats in ImGui overlay
```

The GPU culler runs in parallel with CPU culling for verification. CPU batching
still drives the actual draw calls. GPU visible count is displayed in the runtime
overlay alongside CPU culling stats.

### Tier Update Behavior

| Tier | SSBO Upload | Culling |
|------|-------------|---------|
| Static | On scene rebuild + 3 frames | CPU + GPU (parallel) |
| SemiStatic | On rebuild OR dirty flag | CPU + GPU (parallel) |
| Dynamic | Every frame | CPU + GPU (parallel) |
| Procedural | Placeholder (same as Static) | CPU + GPU (parallel) |

### Future GPU-Driven Architecture (Partially Implemented)

The infrastructure for GPU-driven indirect draw is in place:
- `useIndirection` push constant flag (offset 84) in vertex shader
- `visibleIndices` SSBO at binding 8
- Descriptor set layout and writes include binding 8

**Remaining for full GPU-driven draws (Phase 4.2):**
Per-batch indirect commands require per-batch GPU culling. The current GPUCuller
outputs a flat visible list, not separated by material batch. See
[GPU_CULLING_IMPLEMENTATION.txt](../GPU_CULLING_IMPLEMENTATION.txt) for details.

---

## Table of Contents

1. [Overview](#overview)
2. [Instance Tiers](#instance-tiers)
3. [GPU Data Structures](#gpu-data-structures)
4. [Components](#components)
5. [Compute Culling Pipeline](#compute-culling-pipeline)
6. [Draw Generation](#draw-generation)
7. [Integration Points](#integration-points)

---

## Overview

The multi-tier instance system separates renderable objects by their **update frequency**, enabling optimal GPU utilization:

| Tier | Name | Update Frequency | Culling | Example |
|------|------|------------------|---------|---------|
| 0 | Static | Never | GPU | Terrain, buildings, rocks |
| 1 | Semi-Static | On dirty flag | GPU | Trees (wind sway), doors |
| 2 | Dynamic | Per-frame | CPU | Characters, physics objects |
| 3 | Procedural | Compute-driven | N/A | Particles, grass blades |

### Design Goals

- **Minimize CPU→GPU transfers**: Static data uploaded once
- **GPU-driven culling**: Compute shader frustum + occlusion
- **Indirect drawing**: Single `vkCmdDrawIndexedIndirectCount` per material batch
- **Shadow/RT ready**: Same instance buffers reused for shadow passes and BLAS

---

## Instance Tiers

### Tier 0: Static

Objects that **never move** after level load.

```
Scene Load → Upload to GPU → GPU-resident forever
```

- Model matrices baked at load time
- GPU culling only (no CPU involvement per-frame)
- Perfect for: terrain chunks, buildings, props, flora

### Tier 1: Semi-Static

Objects that move **infrequently** (dirty flag pattern).

```
Change detected → Mark dirty → Next frame: partial buffer update
```

- Transforms updated only when dirty flag set
- GPU culling (same as Tier 0)
- Perfect for: doors opening, tree wind sway, destructibles

### Tier 2: Dynamic

Objects that move **every frame**.

```
Per-frame → CPU updates ring buffer → CPU frustum cull → Issue draws
```

- Ring-buffered instance data (existing infrastructure)
- CPU-side frustum culling (batched)
- Perfect for: player, NPCs, physics-driven objects

### Tier 3: Procedural

Compute-shader generated instances.

```
Compute shader → Populate indirect buffer + instance data → Draw
```

- Instance data generated by compute (particles, grass billboards)
- No CPU involvement except parameters
- Perfect for: particles, procedural grass, debris

---

## GPU Data Structures

### Instance Transform (64 bytes)

```glsl
struct GPUInstanceData {
    mat4 model;          // 64 bytes - world transform
};
```

### Material Properties (64 bytes)

```glsl
struct GPUMaterialData {
    vec4 baseColor;      // 16 bytes - RGBA
    vec4 emissive;       // 16 bytes - RGB + strength
    vec4 matProps;       // 16 bytes - metallic, roughness, normalScale, occlusion
    uint textureIndices; // 4 bytes - packed: base(8)|normal(8)|mr(8)|emissive(8)
    uint flags;          // 4 bytes - packed flags
    vec2 _pad;           // 8 bytes
    // Total: 64 bytes
};
```

### Cull Data (32 bytes)

```glsl
struct GPUCullData {
    vec4 boundingSphere; // 16 bytes - xyz=center (object space), w=radius
    uint meshIndex;      // 4 bytes - for indirect draw indexing
    uint materialIndex;  // 4 bytes - into material SSBO
    uint instanceIndex;  // 4 bytes - into instance transform SSBO
    uint _pad;           // 4 bytes
    // Total: 32 bytes
};
```

### Indirect Draw Command

```glsl
struct VkDrawIndexedIndirectCommand {
    uint indexCount;
    uint instanceCount;     // Filled by compute shader
    uint firstIndex;
    int  vertexOffset;
    uint firstInstance;     // Start offset into visible instance list
};
```

---

## Components

### StaticBatchManager

Manages Tier 0 and Tier 1 instances.

```cpp
class StaticBatchManager {
public:
    void AddInstance(const Transform& transform, MeshHandle mesh, 
                     MaterialHandle material, InstanceTier tier);
    void UpdateInstance(uint32_t instanceId, const mat4& newModel);
    void MarkDirty(uint32_t instanceId);  // For Tier 1
    
    void UploadToGPU();                   // Full upload (load time)
    void FlushDirty();                    // Partial update (per-frame)
    
    VkBuffer GetInstanceBuffer() const;   // GPU-resident transforms
    VkBuffer GetCullDataBuffer() const;   // For compute culling
    uint32_t GetInstanceCount() const;

private:
    std::vector<GPUInstanceData> m_instances;
    std::vector<GPUCullData> m_cullData;
    std::unordered_set<uint32_t> m_dirtySet;
    
    VkBuffer m_instanceBuffer;
    VkBuffer m_cullDataBuffer;
    VkDeviceMemory m_memory;
};
```

### DynamicInstanceManager

Manages Tier 2 instances with ring buffering.

```cpp
class DynamicInstanceManager {
public:
    void BeginFrame(uint32_t frameIndex);
    uint32_t AddInstance(const mat4& model, uint32_t meshIndex, 
                         uint32_t materialIndex);
    void EndFrame();
    
    VkBuffer GetCurrentFrameBuffer() const;
    uint32_t GetInstanceCount() const;
    
private:
    RingBuffer m_ringBuffer;
    std::vector<GPUInstanceData> m_frameInstances;
    uint32_t m_currentFrame;
};
```

### GPUCuller

Compute-shader based frustum culling.

```cpp
class GPUCuller {
public:
    void Initialize(VkDevice device, uint32_t maxInstances);
    void Destroy();
    
    void SetFrustumPlanes(const glm::mat4& viewProj);
    
    // Dispatch culling compute shader
    // Input: cull data buffer
    // Output: visible instance indices + indirect draw commands
    void Cull(VkCommandBuffer cmd, 
              VkBuffer cullDataBuffer, 
              uint32_t instanceCount,
              VkBuffer outputVisibleIndices,
              VkBuffer outputIndirectCommands);
    
    VkBuffer GetVisibleIndicesBuffer() const;
    VkBuffer GetIndirectCommandsBuffer() const;

private:
    VkPipeline m_cullPipeline;
    VkPipelineLayout m_cullPipelineLayout;
    VkDescriptorSetLayout m_cullDescriptorLayout;
    
    // Cull uniform data
    struct CullUniforms {
        glm::vec4 frustumPlanes[6];
        uint32_t instanceCount;
    };
};
```

### RenderSystem

Unified rendering interface.

```cpp
class RenderSystem {
public:
    void Initialize(VkDevice device, const VulkanConfig& config);
    void Destroy();
    
    void RegisterStaticInstance(const StaticInstanceDesc& desc);
    void RegisterDynamicInstance(const DynamicInstanceDesc& desc);
    
    void BeginFrame(uint32_t frameIndex);
    void UpdateCamera(const Camera& camera);
    
    // Tier 0/1: GPU cull + indirect draw
    void DispatchGPUCulling(VkCommandBuffer cmd);
    void DrawStaticInstances(VkCommandBuffer cmd);
    
    // Tier 2: CPU cull + direct draw  
    void UpdateDynamicInstances();
    void DrawDynamicInstances(VkCommandBuffer cmd);
    
    void EndFrame();

private:
    StaticBatchManager m_staticBatches;
    DynamicInstanceManager m_dynamicManager;
    GPUCuller m_gpuCuller;
    
    Camera m_camera;
    uint32_t m_frameIndex;
};
```

---

## Compute Culling Pipeline

### gpu_cull.comp

```glsl
#version 450

layout(local_size_x = 256) in;

// Frustum planes from CPU
layout(std140, set = 0, binding = 0) uniform CullUniforms {
    vec4 frustumPlanes[6];
    uint instanceCount;
} cull;

// Input: per-instance cull data
layout(std430, set = 0, binding = 1) readonly buffer CullDataIn {
    GPUCullData instances[];
} cullDataIn;

// Input: instance transforms (for bounding sphere transform)
layout(std430, set = 0, binding = 2) readonly buffer InstanceDataIn {
    GPUInstanceData instances[];
} instanceDataIn;

// Output: visible instance indices
layout(std430, set = 0, binding = 3) buffer VisibleIndicesOut {
    uint count;
    uint indices[];
} visibleOut;

// Output: indirect draw commands (one per mesh/material batch)
layout(std430, set = 0, binding = 4) buffer IndirectCommandsOut {
    VkDrawIndexedIndirectCommand commands[];
} indirectOut;

bool FrustumCull(vec4 boundingSphere, mat4 model) {
    // Transform sphere center to world space
    vec3 center = (model * vec4(boundingSphere.xyz, 1.0)).xyz;
    float radius = boundingSphere.w * length(model[0].xyz); // Approximate scale
    
    // Test against all 6 frustum planes
    for (int i = 0; i < 6; i++) {
        float dist = dot(cull.frustumPlanes[i].xyz, center) + cull.frustumPlanes[i].w;
        if (dist < -radius) return false; // Outside plane
    }
    return true;
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= cull.instanceCount) return;
    
    GPUCullData cullData = cullDataIn.instances[idx];
    GPUInstanceData instanceData = instanceDataIn.instances[cullData.instanceIndex];
    
    if (FrustumCull(cullData.boundingSphere, instanceData.model)) {
        // Append to visible list (atomic)
        uint visIdx = atomicAdd(visibleOut.count, 1);
        visibleOut.indices[visIdx] = cullData.instanceIndex;
        
        // Increment instance count for this mesh's draw command (atomic)
        atomicAdd(indirectOut.commands[cullData.meshIndex].instanceCount, 1);
    }
}
```

### Integration with Draw

```cpp
// After compute dispatch:
vkCmdDrawIndexedIndirectCount(
    cmd,
    indirectBuffer,                    // Draw commands
    0,                                 // offset
    countBuffer,                       // Number of draws
    countBufferOffset,
    maxDrawCount,
    sizeof(VkDrawIndexedIndirectCommand)
);
```

---

## Draw Generation

### Frame Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│ Frame Start                                                         │
├─────────────────────────────────────────────────────────────────────┤
│ 1. Update Tier 1 dirty instances (CPU → GPU partial upload)        │
│ 2. Update Tier 2 dynamic instances (write to ring buffer)          │
│ 3. CPU frustum cull Tier 2 (build draw list)                       │
├─────────────────────────────────────────────────────────────────────┤
│ Begin Render Pass                                                   │
├─────────────────────────────────────────────────────────────────────┤
│ 4. Dispatch GPU cull compute (Tier 0+1)                            │
│ 5. Memory barrier (compute → indirect)                              │
│ 6. vkCmdDrawIndexedIndirectCount for Tier 0+1                      │
│ 7. Direct draws for Tier 2                                          │
├─────────────────────────────────────────────────────────────────────┤
│ End Render Pass                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Shadow Pass Reuse

The same instance buffers work for shadow mapping:

```cpp
// Shadow pass: same instance data, different view matrix
void RenderShadowPass(VkCommandBuffer cmd, const Light& light) {
    // Reuse static instance buffer
    // Set shadow-specific push constants (light view-proj)
    // Dispatch GPU cull with light frustum
    // Draw to shadow map
}
```

### Ray Tracing BLAS Integration

Static instance transforms feed directly into BLAS:

```cpp
// Build BLAS with static transforms
for (const auto& instance : m_staticInstances) {
    VkAccelerationStructureInstanceKHR asInstance{};
    asInstance.transform = instance.model;
    asInstance.instanceCustomIndex = instance.meshIndex;
    // ...
}
```

---

## Integration Points

### Level Loader

```json
{
  "objects": [
    {
      "name": "terrain_chunk_01",
      "mesh": "terrain.glb",
      "instanceTier": 0
    },
    {
      "name": "door_01",
      "mesh": "door.glb",
      "instanceTier": 1
    },
    {
      "name": "player",
      "mesh": "character.glb",
      "instanceTier": 2
    }
  ]
}
```

### Migration Path

1. **Phase 1**: Implement `StaticBatchManager` for Tier 0
2. **Phase 2**: Add GPU culling compute pipeline
3. **Phase 3**: Add indirect drawing
4. **Phase 4**: Integrate Tier 1 dirty tracking
5. **Phase 5**: Wire existing dynamic system as Tier 2

### Performance Expectations

| Metric | Before (per-object) | After (instanced) |
|--------|---------------------|-------------------|
| Draw calls (1000 static) | 1000 | 1-10 (per material) |
| CPU cull cost (static) | O(n) | 0 (GPU) |
| Buffer updates (static) | O(n) per frame | 0 |
| Shadow pass draws | 1000× lights | 1-10× lights |

---

## Appendix: Push Constant Layout

All shaders use a unified 96-byte push constant block:

```glsl
layout(push_constant) uniform Push {
    mat4 viewProj;        // 64 bytes
    vec4 camPos;          // 16 bytes
    uint batchStartIndex; // 4 bytes
    uint _pad0;           // 4 bytes
    uint _pad1;           // 4 bytes
    uint _pad2;           // 4 bytes
} pc;
```

This enables the same vertex shader for all tiers.

---

## See Also

- [architecture.md](architecture.md) - Core engine architecture
- [shader-pbr-requirements.md](shader-pbr-requirements.md) - PBR specification
- [ROADMAP.md](ROADMAP.md) - Implementation timeline
