# Multi-Tier Instance Rendering System

> A GPU-optimized instancing architecture designed for scalability, shadows, and ray tracing.

---

## Implementation Progress

| Task | Status | Notes |
|------|--------|-------|
| Architecture doc | ✅ Done | This document |
| InstanceTier enum + structs | ✅ Done | `src/render/instance_types.h` |
| StaticBatchManager | ✅ Done | `src/render/static_batch_manager.h/cpp` |
| GPU culling compute shader | ✅ Done | `shaders/source/gpu_cull.comp` |
| GPUCuller class | ✅ Done | `src/render/gpu_culler.h/cpp` |
| RenderSystem wrapper | ✅ Done | `src/render/render_system.h/cpp` |
| Demo scene with all tiers | ✅ Done | `levels/demo/level.json` - All 4 tiers demonstrated |
| Level loader tier support | ⬜ Not Started | Parse `instanceTier` field in level loader |
| Wire into VulkanApp | ⬜ Not Started | Integrate RenderSystem into main app |

---

## Table of Contents

1. [Overview](#overview)
2. [Instance Tiers](#instance-tiers)
3. [GPU Data Structures](#gpu-data-structures)
4. [Components](#components)
5. [Compute Culling Pipeline](#compute-culling-pipeline)
6. [Draw Generation](#draw-generation)
7. [Integration Points](#integration-points)

---

## Overview

The multi-tier instance system separates renderable objects by their **update frequency**, enabling optimal GPU utilization:

| Tier | Name | Update Frequency | Culling | Example |
|------|------|------------------|---------|---------|
| 0 | Static | Never | GPU | Terrain, buildings, rocks |
| 1 | Semi-Static | On dirty flag | GPU | Trees (wind sway), doors |
| 2 | Dynamic | Per-frame | CPU | Characters, physics objects |
| 3 | Procedural | Compute-driven | N/A | Particles, grass blades |

### Design Goals

- **Minimize CPU→GPU transfers**: Static data uploaded once
- **GPU-driven culling**: Compute shader frustum + occlusion
- **Indirect drawing**: Single `vkCmdDrawIndexedIndirectCount` per material batch
- **Shadow/RT ready**: Same instance buffers reused for shadow passes and BLAS

---

## Instance Tiers

### Tier 0: Static

Objects that **never move** after level load.

```
Scene Load → Upload to GPU → GPU-resident forever
```

- Model matrices baked at load time
- GPU culling only (no CPU involvement per-frame)
- Perfect for: terrain chunks, buildings, props, flora

### Tier 1: Semi-Static

Objects that move **infrequently** (dirty flag pattern).

```
Change detected → Mark dirty → Next frame: partial buffer update
```

- Transforms updated only when dirty flag set
- GPU culling (same as Tier 0)
- Perfect for: doors opening, tree wind sway, destructibles

### Tier 2: Dynamic

Objects that move **every frame**.

```
Per-frame → CPU updates ring buffer → CPU frustum cull → Issue draws
```

- Ring-buffered instance data (existing infrastructure)
- CPU-side frustum culling (batched)
- Perfect for: player, NPCs, physics-driven objects

### Tier 3: Procedural

Compute-shader generated instances.

```
Compute shader → Populate indirect buffer + instance data → Draw
```

- Instance data generated by compute (particles, grass billboards)
- No CPU involvement except parameters
- Perfect for: particles, procedural grass, debris

---

## GPU Data Structures

### Instance Transform (64 bytes)

```glsl
struct GPUInstanceData {
    mat4 model;          // 64 bytes - world transform
};
```

### Material Properties (64 bytes)

```glsl
struct GPUMaterialData {
    vec4 baseColor;      // 16 bytes - RGBA
    vec4 emissive;       // 16 bytes - RGB + strength
    vec4 matProps;       // 16 bytes - metallic, roughness, normalScale, occlusion
    uint textureIndices; // 4 bytes - packed: base(8)|normal(8)|mr(8)|emissive(8)
    uint flags;          // 4 bytes - packed flags
    vec2 _pad;           // 8 bytes
    // Total: 64 bytes
};
```

### Cull Data (32 bytes)

```glsl
struct GPUCullData {
    vec4 boundingSphere; // 16 bytes - xyz=center (object space), w=radius
    uint meshIndex;      // 4 bytes - for indirect draw indexing
    uint materialIndex;  // 4 bytes - into material SSBO
    uint instanceIndex;  // 4 bytes - into instance transform SSBO
    uint _pad;           // 4 bytes
    // Total: 32 bytes
};
```

### Indirect Draw Command

```glsl
struct VkDrawIndexedIndirectCommand {
    uint indexCount;
    uint instanceCount;     // Filled by compute shader
    uint firstIndex;
    int  vertexOffset;
    uint firstInstance;     // Start offset into visible instance list
};
```

---

## Components

### StaticBatchManager

Manages Tier 0 and Tier 1 instances.

```cpp
class StaticBatchManager {
public:
    void AddInstance(const Transform& transform, MeshHandle mesh, 
                     MaterialHandle material, InstanceTier tier);
    void UpdateInstance(uint32_t instanceId, const mat4& newModel);
    void MarkDirty(uint32_t instanceId);  // For Tier 1
    
    void UploadToGPU();                   // Full upload (load time)
    void FlushDirty();                    // Partial update (per-frame)
    
    VkBuffer GetInstanceBuffer() const;   // GPU-resident transforms
    VkBuffer GetCullDataBuffer() const;   // For compute culling
    uint32_t GetInstanceCount() const;

private:
    std::vector<GPUInstanceData> m_instances;
    std::vector<GPUCullData> m_cullData;
    std::unordered_set<uint32_t> m_dirtySet;
    
    VkBuffer m_instanceBuffer;
    VkBuffer m_cullDataBuffer;
    VkDeviceMemory m_memory;
};
```

### DynamicInstanceManager

Manages Tier 2 instances with ring buffering.

```cpp
class DynamicInstanceManager {
public:
    void BeginFrame(uint32_t frameIndex);
    uint32_t AddInstance(const mat4& model, uint32_t meshIndex, 
                         uint32_t materialIndex);
    void EndFrame();
    
    VkBuffer GetCurrentFrameBuffer() const;
    uint32_t GetInstanceCount() const;
    
private:
    RingBuffer m_ringBuffer;
    std::vector<GPUInstanceData> m_frameInstances;
    uint32_t m_currentFrame;
};
```

### GPUCuller

Compute-shader based frustum culling.

```cpp
class GPUCuller {
public:
    void Initialize(VkDevice device, uint32_t maxInstances);
    void Destroy();
    
    void SetFrustumPlanes(const glm::mat4& viewProj);
    
    // Dispatch culling compute shader
    // Input: cull data buffer
    // Output: visible instance indices + indirect draw commands
    void Cull(VkCommandBuffer cmd, 
              VkBuffer cullDataBuffer, 
              uint32_t instanceCount,
              VkBuffer outputVisibleIndices,
              VkBuffer outputIndirectCommands);
    
    VkBuffer GetVisibleIndicesBuffer() const;
    VkBuffer GetIndirectCommandsBuffer() const;

private:
    VkPipeline m_cullPipeline;
    VkPipelineLayout m_cullPipelineLayout;
    VkDescriptorSetLayout m_cullDescriptorLayout;
    
    // Cull uniform data
    struct CullUniforms {
        glm::vec4 frustumPlanes[6];
        uint32_t instanceCount;
    };
};
```

### RenderSystem

Unified rendering interface.

```cpp
class RenderSystem {
public:
    void Initialize(VkDevice device, const VulkanConfig& config);
    void Destroy();
    
    void RegisterStaticInstance(const StaticInstanceDesc& desc);
    void RegisterDynamicInstance(const DynamicInstanceDesc& desc);
    
    void BeginFrame(uint32_t frameIndex);
    void UpdateCamera(const Camera& camera);
    
    // Tier 0/1: GPU cull + indirect draw
    void DispatchGPUCulling(VkCommandBuffer cmd);
    void DrawStaticInstances(VkCommandBuffer cmd);
    
    // Tier 2: CPU cull + direct draw  
    void UpdateDynamicInstances();
    void DrawDynamicInstances(VkCommandBuffer cmd);
    
    void EndFrame();

private:
    StaticBatchManager m_staticBatches;
    DynamicInstanceManager m_dynamicManager;
    GPUCuller m_gpuCuller;
    
    Camera m_camera;
    uint32_t m_frameIndex;
};
```

---

## Compute Culling Pipeline

### gpu_cull.comp

```glsl
#version 450

layout(local_size_x = 256) in;

// Frustum planes from CPU
layout(std140, set = 0, binding = 0) uniform CullUniforms {
    vec4 frustumPlanes[6];
    uint instanceCount;
} cull;

// Input: per-instance cull data
layout(std430, set = 0, binding = 1) readonly buffer CullDataIn {
    GPUCullData instances[];
} cullDataIn;

// Input: instance transforms (for bounding sphere transform)
layout(std430, set = 0, binding = 2) readonly buffer InstanceDataIn {
    GPUInstanceData instances[];
} instanceDataIn;

// Output: visible instance indices
layout(std430, set = 0, binding = 3) buffer VisibleIndicesOut {
    uint count;
    uint indices[];
} visibleOut;

// Output: indirect draw commands (one per mesh/material batch)
layout(std430, set = 0, binding = 4) buffer IndirectCommandsOut {
    VkDrawIndexedIndirectCommand commands[];
} indirectOut;

bool FrustumCull(vec4 boundingSphere, mat4 model) {
    // Transform sphere center to world space
    vec3 center = (model * vec4(boundingSphere.xyz, 1.0)).xyz;
    float radius = boundingSphere.w * length(model[0].xyz); // Approximate scale
    
    // Test against all 6 frustum planes
    for (int i = 0; i < 6; i++) {
        float dist = dot(cull.frustumPlanes[i].xyz, center) + cull.frustumPlanes[i].w;
        if (dist < -radius) return false; // Outside plane
    }
    return true;
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= cull.instanceCount) return;
    
    GPUCullData cullData = cullDataIn.instances[idx];
    GPUInstanceData instanceData = instanceDataIn.instances[cullData.instanceIndex];
    
    if (FrustumCull(cullData.boundingSphere, instanceData.model)) {
        // Append to visible list (atomic)
        uint visIdx = atomicAdd(visibleOut.count, 1);
        visibleOut.indices[visIdx] = cullData.instanceIndex;
        
        // Increment instance count for this mesh's draw command (atomic)
        atomicAdd(indirectOut.commands[cullData.meshIndex].instanceCount, 1);
    }
}
```

### Integration with Draw

```cpp
// After compute dispatch:
vkCmdDrawIndexedIndirectCount(
    cmd,
    indirectBuffer,                    // Draw commands
    0,                                 // offset
    countBuffer,                       // Number of draws
    countBufferOffset,
    maxDrawCount,
    sizeof(VkDrawIndexedIndirectCommand)
);
```

---

## Draw Generation

### Frame Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│ Frame Start                                                         │
├─────────────────────────────────────────────────────────────────────┤
│ 1. Update Tier 1 dirty instances (CPU → GPU partial upload)        │
│ 2. Update Tier 2 dynamic instances (write to ring buffer)          │
│ 3. CPU frustum cull Tier 2 (build draw list)                       │
├─────────────────────────────────────────────────────────────────────┤
│ Begin Render Pass                                                   │
├─────────────────────────────────────────────────────────────────────┤
│ 4. Dispatch GPU cull compute (Tier 0+1)                            │
│ 5. Memory barrier (compute → indirect)                              │
│ 6. vkCmdDrawIndexedIndirectCount for Tier 0+1                      │
│ 7. Direct draws for Tier 2                                          │
├─────────────────────────────────────────────────────────────────────┤
│ End Render Pass                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Shadow Pass Reuse

The same instance buffers work for shadow mapping:

```cpp
// Shadow pass: same instance data, different view matrix
void RenderShadowPass(VkCommandBuffer cmd, const Light& light) {
    // Reuse static instance buffer
    // Set shadow-specific push constants (light view-proj)
    // Dispatch GPU cull with light frustum
    // Draw to shadow map
}
```

### Ray Tracing BLAS Integration

Static instance transforms feed directly into BLAS:

```cpp
// Build BLAS with static transforms
for (const auto& instance : m_staticInstances) {
    VkAccelerationStructureInstanceKHR asInstance{};
    asInstance.transform = instance.model;
    asInstance.instanceCustomIndex = instance.meshIndex;
    // ...
}
```

---

## Integration Points

### Level Loader

```json
{
  "objects": [
    {
      "name": "terrain_chunk_01",
      "mesh": "terrain.glb",
      "instanceTier": 0
    },
    {
      "name": "door_01",
      "mesh": "door.glb",
      "instanceTier": 1
    },
    {
      "name": "player",
      "mesh": "character.glb",
      "instanceTier": 2
    }
  ]
}
```

### Migration Path

1. **Phase 1**: Implement `StaticBatchManager` for Tier 0
2. **Phase 2**: Add GPU culling compute pipeline
3. **Phase 3**: Add indirect drawing
4. **Phase 4**: Integrate Tier 1 dirty tracking
5. **Phase 5**: Wire existing dynamic system as Tier 2

### Performance Expectations

| Metric | Before (per-object) | After (instanced) |
|--------|---------------------|-------------------|
| Draw calls (1000 static) | 1000 | 1-10 (per material) |
| CPU cull cost (static) | O(n) | 0 (GPU) |
| Buffer updates (static) | O(n) per frame | 0 |
| Shadow pass draws | 1000× lights | 1-10× lights |

---

## Appendix: Push Constant Layout

All shaders use a unified 96-byte push constant block:

```glsl
layout(push_constant) uniform Push {
    mat4 viewProj;        // 64 bytes
    vec4 camPos;          // 16 bytes
    uint batchStartIndex; // 4 bytes
    uint _pad0;           // 4 bytes
    uint _pad1;           // 4 bytes
    uint _pad2;           // 4 bytes
} pc;
```

This enables the same vertex shader for all tiers.

---

## See Also

- [architecture.md](architecture.md) - Core engine architecture
- [shader-pbr-requirements.md](shader-pbr-requirements.md) - PBR specification
- [ROADMAP.md](ROADMAP.md) - Implementation timeline
