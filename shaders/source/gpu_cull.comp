#version 450

/*
 * GPU Frustum Culling Compute Shader
 * 
 * Input:
 *   - All objects with transforms and bounding spheres
 *   - Camera frustum planes (6 planes)
 *   
 * Output:
 *   - Compacted visible instance indices
 *   - Indirect draw command with instance count
 *
 * Each workgroup thread tests one object against the frustum.
 * Visible objects atomically append their index to the output buffer.
 */

// Workgroup size: 256 threads (good balance for most GPUs)
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// ============================================================================
// Structures (must match C++ side)
// ============================================================================

// Per-object culling data (separate from render ObjectData for efficiency)
struct CullObjectData {
    vec4 boundingSphere;  // xyz = center (world space), w = radius
    uint objectIndex;     // Index into ObjectData SSBO for rendering
    uint batchId;         // Which batch this object belongs to (for multi-batch indirect)
    uint _pad0;
    uint _pad1;
};

// Frustum planes (Ax + By + Cz + D = 0, normal pointing inward)
struct FrustumData {
    vec4 planes[6];       // left, right, bottom, top, near, far
    uint objectCount;     // Total objects to cull
    uint batchCount;      // Number of active batches
    uint maxObjectsPerBatch; // Max visible objects per batch section
    uint _pad0;
};

// Indirect draw command (VkDrawIndirectCommand for non-indexed draw)
struct DrawCommand {
    uint vertexCount;
    uint instanceCount;
    uint firstVertex;
    uint firstInstance;
};

// ============================================================================
// Descriptor Set Bindings
// ============================================================================

// Set 0, Binding 0: Frustum data (uniform buffer, updated per-frame)
layout(std140, set = 0, binding = 0) uniform FrustumBuffer {
    FrustumData frustum;
};

// Set 0, Binding 1: All objects to cull (read-only storage buffer)
layout(std430, set = 0, binding = 1) readonly buffer CullInputBuffer {
    CullObjectData cullObjects[];
};

// Set 0, Binding 2: Visible instance indices output (write storage buffer)
layout(std430, set = 0, binding = 2) writeonly buffer VisibleIndicesBuffer {
    uint visibleIndices[];
};

// Set 0, Binding 3: Atomic counter for visible count (read-write storage buffer)
layout(std430, set = 0, binding = 3) buffer AtomicCounterBuffer {
    uint visibleCount;
};

// Set 0, Binding 4: Indirect draw commands (write storage buffer)
// One command per batch for multi-draw indirect
layout(std430, set = 0, binding = 4) buffer IndirectCommandBuffer {
    DrawCommand drawCommands[];
};

// Set 0, Binding 5: Per-batch atomic counters for visible count
layout(std430, set = 0, binding = 5) buffer BatchCountersBuffer {
    uint batchCounters[];
};

// ============================================================================
// Frustum Test
// ============================================================================

// Test sphere against frustum planes
// Returns true if sphere is at least partially inside frustum
bool SphereInFrustum(vec3 center, float radius) {
    for (int i = 0; i < 6; ++i) {
        vec4 plane = frustum.planes[i];
        float distance = dot(plane.xyz, center) + plane.w;
        if (distance < -radius) {
            return false;  // Fully outside this plane
        }
    }
    return true;  // Inside or intersecting all planes
}

// ============================================================================
// Main
// ============================================================================

void main() {
    uint gid = gl_GlobalInvocationID.x;
    
    // Bounds check
    if (gid >= frustum.objectCount) {
        return;
    }
    
    // Load object culling data
    CullObjectData obj = cullObjects[gid];
    vec3 center = obj.boundingSphere.xyz;
    float radius = obj.boundingSphere.w;
    
    // Skip objects with zero radius (invalid bounds)
    if (radius <= 0.0) {
        return;
    }
    
    // Frustum test
    if (SphereInFrustum(center, radius)) {
        uint batchId = obj.batchId;
        
        // Increment global visible count (for debugging/stats)
        atomicAdd(visibleCount, 1);
        
        // Per-batch output: each batch has its own section in visibleIndices
        // Section for batchId starts at: batchId * maxObjectsPerBatch
        uint localSlot = atomicAdd(batchCounters[batchId], 1);
        
        // Prevent overflow: only write if within batch section
        if (localSlot < frustum.maxObjectsPerBatch) {
            uint globalSlot = batchId * frustum.maxObjectsPerBatch + localSlot;
            visibleIndices[globalSlot] = obj.objectIndex;
            
            // Increment instance count in this batch's draw command
            atomicAdd(drawCommands[batchId].instanceCount, 1);
        }
    }
}
