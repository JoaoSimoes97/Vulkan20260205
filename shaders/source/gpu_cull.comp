#version 450

/*
 * GPU Frustum Culling Compute Shader
 * 
 * Input:
 *   - All objects with transforms and bounding spheres
 *   - Camera frustum planes (6 planes)
 *   
 * Output:
 *   - Compacted visible instance indices
 *   - Indirect draw command with instance count
 *
 * Each workgroup thread tests one object against the frustum.
 * Visible objects atomically append their index to the output buffer.
 */

// Workgroup size: 256 threads (good balance for most GPUs)
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// ============================================================================
// Structures (must match C++ side)
// ============================================================================

// Per-object culling data (separate from render ObjectData for efficiency)
struct CullObjectData {
    vec4 boundingSphere;  // xyz = center (world space), w = radius
    uint objectIndex;     // Index into ObjectData SSBO for rendering
    uint batchId;         // Which batch this object belongs to (for multi-batch indirect)
    uint _pad0;
    uint _pad1;
};

// Frustum planes (Ax + By + Cz + D = 0, normal pointing inward)
struct FrustumData {
    vec4 planes[6];       // left, right, bottom, top, near, far
    uint objectCount;     // Total objects to cull
    uint _pad0;
    uint _pad1;
    uint _pad2;
};

// Indirect draw command (VkDrawIndexedIndirectCommand)
struct DrawCommand {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int  vertexOffset;
    uint firstInstance;
};

// ============================================================================
// Descriptor Set Bindings
// ============================================================================

// Set 0, Binding 0: Frustum data (uniform buffer, updated per-frame)
layout(std140, set = 0, binding = 0) uniform FrustumBuffer {
    FrustumData frustum;
};

// Set 0, Binding 1: All objects to cull (read-only storage buffer)
layout(std430, set = 0, binding = 1) readonly buffer CullInputBuffer {
    CullObjectData cullObjects[];
};

// Set 0, Binding 2: Visible instance indices output (write storage buffer)
layout(std430, set = 0, binding = 2) writeonly buffer VisibleIndicesBuffer {
    uint visibleIndices[];
};

// Set 0, Binding 3: Atomic counter for visible count (read-write storage buffer)
layout(std430, set = 0, binding = 3) buffer AtomicCounterBuffer {
    uint visibleCount;
};

// Set 0, Binding 4: Indirect draw commands (write storage buffer)
// For now: single draw command. Future: one per batch.
layout(std430, set = 0, binding = 4) buffer IndirectCommandBuffer {
    DrawCommand drawCommands[];
};

// ============================================================================
// Frustum Test
// ============================================================================

// Test sphere against frustum planes
// Returns true if sphere is at least partially inside frustum
bool SphereInFrustum(vec3 center, float radius) {
    for (int i = 0; i < 6; ++i) {
        vec4 plane = frustum.planes[i];
        float distance = dot(plane.xyz, center) + plane.w;
        if (distance < -radius) {
            return false;  // Fully outside this plane
        }
    }
    return true;  // Inside or intersecting all planes
}

// ============================================================================
// Main
// ============================================================================

void main() {
    uint gid = gl_GlobalInvocationID.x;
    
    // Bounds check
    if (gid >= frustum.objectCount) {
        return;
    }
    
    // Load object culling data
    CullObjectData obj = cullObjects[gid];
    vec3 center = obj.boundingSphere.xyz;
    float radius = obj.boundingSphere.w;
    
    // Skip objects with zero radius (invalid bounds)
    if (radius <= 0.0) {
        return;
    }
    
    // Frustum test
    if (SphereInFrustum(center, radius)) {
        // Object is visible: atomically append to output
        uint slot = atomicAdd(visibleCount, 1);
        visibleIndices[slot] = obj.objectIndex;
        
        // Increment instance count in draw command
        // For single-batch: always command 0
        // Future: use obj.batchId to select command
        atomicAdd(drawCommands[0].instanceCount, 1);
    }
}
